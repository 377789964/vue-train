<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app"></div>
    <script type="module">
        // reactive 创建一个响应式对象
        // effect 副作用函数 默认会执行一次， 数据变化后会再次执行
        // import { reactive, effect, computed } from "/node_modules/@vue/reactivity/dist/reactivity.esm-browser.js"
        import { reactive, effect, watch, watchEffect } from './reactivity.esm.js'

        const state = reactive({
            flag: true,
            name: 'jw',
            age: 30,
            n: {
                n: 1
            }
        })

        // 当数据变化后，我希望根据最新的水 获取结果
        // 第一次 数据变化了 我会调用一个接口，getData() 1000ms 返回一个值 1
        // 第二次 数据变化了 我会再调用一个接口 getData() 500ms 返回一个值 2
        // 最终页面显示的结果是
        // watchEffect(() => {
        //     document.getElementById('app').innerHTML = state.name
        // })

        let timer = 3000

        function getData(data) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve(data)
                }, timer -= 1000)
            })
        }
        // vue2中如何解决这个问题
        // 防抖 就是多次出触发，只用第一次
        // 截流 按照频率触发
        let arr = []
        watch(() => state.name, async function(newValue, oldVaule, onCleanup) {
            // vue2的解决方式
            // let flag = true
            // while(arr.length > 0) {
            //     let cb = arr.shift() // 取出来数组中的回调就销毁了不会太大占内存
            //     cb()
            // }
            // arr.push(() => { // 这个函数是闭包
            //     flag = false
            // })
            // const r  = await getData(newValue)
            // if(flag) {
            //     console.log(newValue, flag, 'watch')
            //     app.innerHTML = r
            // }
            // vue3提供了onCleanup方法
            let flag = true
            onCleanup(() => {
                flag = false
            })
            const r  = await getData(newValue)
            if(flag) {
                console.log(newValue, flag, 'watch')
                app.innerHTML = r
            }
            
        })

        state.name = 1
        state.name = 2
        // 会先看到2再看到1
        

    </script>
    
</body>
</html>